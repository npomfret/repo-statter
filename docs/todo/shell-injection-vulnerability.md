# Shell Injection Vulnerability

## Problem
- **Location**: Three instances in `src/git/parser.ts`:
  - Line 126: `cd "${repoPath}" && git ls-tree -r HEAD --name-only`
  - Line 156: `cd "${repoPath}" && git rev-parse ${commitHash}^`
  - Line 185: `cd "${repoPath}" && git show ${commitHash} --numstat --format=""`
- **Description**: User-controlled input (repoPath, commitHash) is directly interpolated into shell commands without proper escaping
- **Current vs Expected**: Direct string interpolation vs using simple-git library methods or properly escaped commands

## Detailed Analysis

### Vulnerable Code Locations:

1. **getCurrentFiles() - Line 126**
   - Uses execAsync with `git ls-tree -r HEAD --name-only`
   - Vulnerable to shell injection via `repoPath`

2. **parseCommitDiff() - Line 156**
   - Uses execAsync with `git rev-parse ${commitHash}^`
   - Vulnerable to shell injection via both `repoPath` and `commitHash`

3. **getByteChanges() - Line 185**
   - Uses execAsync with `git show ${commitHash} --numstat --format=""`
   - Vulnerable to shell injection via both `repoPath` and `commitHash`

## Solution

### Approach 1: Use simple-git library methods (Preferred)
Since simple-git is already used in the codebase, extend its usage to replace vulnerable execAsync calls:

1. **getCurrentFiles()**: Use simple-git's raw method or tree method
2. **parseCommitDiff()**: Use simple-git's revparse method for commit validation
3. **getByteChanges()**: Use simple-git's show method with appropriate options

### Approach 2: If simple-git methods not available, use spawn with argument arrays
Replace execAsync with spawn to avoid shell interpretation:

```typescript
import { spawn } from 'child_process'

async function runGitCommand(cwd: string, args: string[]): Promise<string> {
  return new Promise((resolve, reject) => {
    const git = spawn('git', args, { cwd })
    let stdout = ''
    let stderr = ''
    
    git.stdout.on('data', data => stdout += data)
    git.stderr.on('data', data => stderr += data)
    
    git.on('close', code => {
      if (code !== 0) {
        reject(new Error(`Git command failed: ${stderr}`))
      } else {
        resolve(stdout)
      }
    })
  })
}
```

## Detailed Implementation Plan

### Step 1: Fix getCurrentFiles() (Line 126)
- Replace execAsync with simple-git's raw method:
  ```typescript
  const files = await git.raw(['ls-tree', '-r', 'HEAD', '--name-only'])
  ```

### Step 2: Fix parseCommitDiff() (Line 156)
- Replace execAsync for rev-parse with simple-git's revparse:
  ```typescript
  try {
    await git.revparse([`${commitHash}^`])
  } catch {
    isFirstCommit = true
  }
  ```

### Step 3: Fix getByteChanges() (Line 185)
- Replace execAsync with simple-git's show:
  ```typescript
  const stdout = await git.show([commitHash, '--numstat', '--format='])
  ```

### Step 4: Test each fix
- Create test cases that would exploit the vulnerability
- Verify fixes prevent shell injection
- Ensure functionality remains intact

### Step 5: Run existing tests
- `npm run test`
- `npm run typecheck`
- Test with `./scripts/run-tests.sh`

## Impact
- **Type**: Security fix - prevents shell injection attacks
- **Risk**: Low (using existing library methods)
- **Complexity**: Low-Moderate
- **Benefit**: Critical - eliminates security vulnerability

## Implementation Notes
- Prefer simple-git library methods over raw shell commands
- All three vulnerabilities must be fixed as they all accept user input
- Maintain existing error handling behavior
- No changes to function signatures or return types